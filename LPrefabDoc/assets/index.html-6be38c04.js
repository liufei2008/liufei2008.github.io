import{_ as n,r as i,o as c,c as l,a as e,b as t,d as o,w as s,e as a}from"./app-a7e9bcae.js";const d="/LPrefabDoc/assets/CreatePrefabInLevelEditor_1-64a2f67c.png",f="/LPrefabDoc/assets/CreatePrefabInLevelEditor_2-0778c318.png",p="/LPrefabDoc/assets/CreatePrefabInLevelEditor_3-15349693.png",h="/LPrefabDoc/assets/CreatePrefabInLevelEditor_4-9b88fb57.png",b="/LPrefabDoc/assets/CreatePrefabInLevelEditor_5-a113890b.png",u="/LPrefabDoc/assets/CreatePrefabInContentBrowser_1-50b32dc8.png",m="/LPrefabDoc/assets/CreatePrefabInContentBrowser_2-ab900c54.png",P="/LPrefabDoc/assets/CreatePrefabInContentBrowser_3-79fb1bc0.png",_="/LPrefabDoc/assets/CreatePrefabInContentBrowser_4-e560262a.png",g="/LPrefabDoc/assets/CreatePrefabInContentBrowser_5-d2293c1f.png",w="/LPrefabDoc/assets/CreatePrefabInContentBrowser_6-328aaffc.png",L="/LPrefabDoc/assets/PrefabEditor_1-6530b0b7.png",q="/LPrefabDoc/assets/PrefabEditor_2-146271e8.png",y="/LPrefabDoc/assets/PrefabEditor_3-3aeddeac.png",v="/LPrefabDoc/assets/PrefabEditor_4-54bbfa33.png",A="/LPrefabDoc/assets/PrefabEditor_5-4f69a381.png",C="/LPrefabDoc/assets/LevelEditor_1-d7899339.png",D="/LPrefabDoc/assets/LevelEditor_2-e70e3453.png",E="/LPrefabDoc/assets/RuntimeUse_1-0288d842.png",k="/LPrefabDoc/assets/RuntimeUse_2-3c5a6324.png",I="/LPrefabDoc/assets/RuntimeUse_3-8f6b4b71.png",x="/LPrefabDoc/assets/1-d31b8478.png",B="/LPrefabDoc/assets/RuntimeUse_5-4367e5fc.png",T="/LPrefabDoc/assets/RuntimeUse_6-8e6bc724.png",N="/LPrefabDoc/assets/RuntimeUse_7-887ff04a.png",R="/LPrefabDoc/assets/NestedPrefab_1-add2a566.png",S="/LPrefabDoc/assets/NestedPrefab_2-06daf0f7.png",z="/LPrefabDoc/assets/NestedPrefab_3-9d3c33a5.png",U="/LPrefabDoc/assets/NestedPrefab_4-b9a93cfe.png",M={},O=a('<h1 id="lprefab-lex-prefab" tabindex="-1"><a class="header-anchor" href="#lprefab-lex-prefab" aria-hidden="true">#</a> LPrefab (Lex Prefab)</h1><p>预制体是一组Actor集合，可以保存为资源并在需要的时候还原这些Actor到场景里。</p><p>当构建场景的时候经常会需要创建一些Actor组，然后在场景里多次复用或用到另一个场景里。就比如一个火把，火把包含几个静态网格、几个光源、火焰粒子，还可以有脚本。预制体允许我们创建这样的集合，然后保存为预制体资产。然后你可以在Content Browser里选择这个资产，并在场景里创建多个这样的集合实例。</p><p>预制体可以修改属性，修改的属性还能同步应用到场景中的其他预制体实例上。其他预制体实例在更新时，只有与原始预制体的属性值相同的属性才会被更新。举个例子，假如有个预制体里面包含了一个黄色的光源，然后修改一个预制体的实例的光源颜色为蓝色，然后修改原始预制体的光源颜色为绿色。那么只有黄色光源的预制体实例才会更新为绿色。这个特性非常有用，因为这样允许我们修改预制体实例中的一部分内容以适用于不同的应用场景，并且也能更新预制体。</p><h2 id="创建预制体" tabindex="-1"><a class="header-anchor" href="#创建预制体" aria-hidden="true">#</a> 创建预制体</h2><p>有两种方式可以创建预制体，我们以创建个火把为例。</p><h3 id="在场景编辑器中创建预制体" tabindex="-1"><a class="header-anchor" href="#在场景编辑器中创建预制体" aria-hidden="true">#</a> 在场景编辑器中创建预制体</h3><p>在场景里创建个简单的火把，然后把这些Actor都放到一个根Actor上。火把是由2个盒子+1个圆柱体+4个点光源组成： <img src="'+d+'" alt=""> 选择根Actor，右键点击LPrefab栏然后在弹出菜单选择<strong>Create Prefab</strong>：<br><img src="'+f+'" alt=""> 然后会弹出对话框，选择个位置和文件名来保存资源： <img src="'+p+'" alt=""> 点击“保存”按钮，然后就会在Content目录中创建一个预制体资源，并且场景中这些预制体的Actor在Outliner的LPrefab栏都会显示“Prefab”图标： <img src="'+h+'" alt=""> Now we can delete the actors in level. Right-click on LPrefab column of root actor and choose &quot;Destroy Actors&quot;:<br><img src="'+b+'" alt=""></p><h3 id="create-prefab-in-content-browser" tabindex="-1"><a class="header-anchor" href="#create-prefab-in-content-browser" aria-hidden="true">#</a> Create Prefab in Content Browser</h3><p>Right-click on Content Browser and select LPrefab: <img src="'+u+'" alt=""> Then a popup window will appear, in this window we can select a type of Actor as the root actor of the Prefab. Just choose the default empty &quot;Actor&quot;: <img src="'+m+'" alt=""> Then a Prefab asset will be created in Content Browser, name it &quot;Torch&quot;: <img src="'+P+'" alt=""> Double click the &quot;Torch&quot; Prefab asset, this will open a Prefab Editor window for us to edit the newly created &quot;Torch&quot; Prefab: <img src="'+_+'" alt=""> Now we can add shapes and lights to our &quot;Torch&quot;, by right click on LPrefab column and click to create these items: <img src="'+g+'" alt=""> After you finish create the &quot;Torch&quot;, hit &quot;Apply&quot; button to save the Prefab: <img src="'+w+'" alt=""> Now you can close the Prefab Editor window.</p><h2 id="edit-prefab" tabindex="-1"><a class="header-anchor" href="#edit-prefab" aria-hidden="true">#</a> Edit Prefab</h2><p>There are two ways to eidt/modify existing prefabs.</p><h3 id="edit-prefab-in-prefab-editor" tabindex="-1"><a class="header-anchor" href="#edit-prefab-in-prefab-editor" aria-hidden="true">#</a> Edit Prefab in Prefab-Editor</h3><p>Just double-click the Prefab asset and will bring-up a Prefab-Editor window: <img src="'+L+'" alt=""><em>LPrefab will automatically create a root actor named &quot;[temporary_RootAgent]&quot;, as the name means this actor is temporary created just as a root holder.</em><br> In the Prefab-Editor window, you can do anything you want to edit/modify the prefab. Lets edit something for example.</p><p>Select &quot;Cube&quot; actor and right-click on LPrefab column then select &quot;Create Actor&quot;-&gt;&quot;All Actors&quot; then typein &quot;StaticMesh&quot;, this will create a StaticMeshActor under &quot;Cube&quot; actor:<br><img src="'+q+'" alt=""><img src="'+y+'" alt=""> Rename the actor to &quot;Sphere&quot; and assign a sphere static mesh to it:<br><img src="'+v+'" alt=""></p><p>Now the important part, click-on &quot;Apply&quot; button on the left-top size of the editor window:<br><img src="'+A+'" alt=""></p><p>The &quot;Apply&quot; button will save your changed properties to Prefab asset, so always rememeber to hit it.</p>',17),j=a('<h3 id="edit-prefab-in-level-editor" tabindex="-1"><a class="header-anchor" href="#edit-prefab-in-level-editor" aria-hidden="true">#</a> Edit Prefab in Level-Editor</h3><p>Drag your Prefab asset and drop it in Level-Editor&#39;s viewport, this will create an instance of the Prefab asset: <img src="'+C+'" alt=""><em>Note, if you select an actor in Level-Editor then drag-drop the Prefab, then the created Prefab instance will attach to the selected actor.</em></p><p>When edit a Prefab instance in Level-Editor, LPrefab actually consider it as a Sub-Prefab, so features and limititions are same, see <em>Nested Prefab and Property Override</em> section below.</p><h3 id="delete-prefab-in-level-editor" tabindex="-1"><a class="header-anchor" href="#delete-prefab-in-level-editor" aria-hidden="true">#</a> Delete Prefab in Level-Editor</h3><p>Select the root actor of your Prefab instance in Level-Editor, then right click on LPrefab column in outliner, and click &quot;Destroy Actors&quot;:<br><img src="'+D+'" alt=""></p><p><strong>NOTE!!! The &quot;Destroy Actors&quot; can destroy selected actors with it&#39;s attached children actors.</strong></p><h2 id="load-prefab-at-runtime" tabindex="-1"><a class="header-anchor" href="#load-prefab-at-runtime" aria-hidden="true">#</a> Load Prefab at runtime</h2><p>LPrefab provide a some function to load it at runtime, you can easily call it in Blueprint and c++: <img src="'+E+'" alt=""><strong>LoadPrefab</strong>: Most commonly used function</p><ul><li>InParent: Provide a SceneComponent as parent, so the loaded Prefab&#39;s root actor will attach to the parent.</li><li>SetRelativeTransformToIdentity: true- Reset the loaded Prefab&#39;s root actor&#39;s transform value; false- Keep origin value. <strong>LoadPrefabWithTransform</strong>: Replace the loaded Prefab&#39;s root actor&#39;s transform value with provided one.<br><strong>LoadPrefabWithReplacement</strong>: This function give us an opportunity to replace the Prefab&#39;s referenced assets or class before load the Prefab. Useful in the case that, we create a PrefabA, and a component CompA at the root actor to manage the PrefabA, then we create a CompB which have the same properties as CompA, but with different function implementation, then we can use this function to load PrefabA and replace class from CompA to CompB; But remember, Prefab serialize depend on UProperty, so CompA and CompB must have same UProperty.</li><li>InReplaceAssetMap: Map from asset to another, maybe a static mesh.</li><li>InReplaceClassMap: Map from class to another, in the above example, we can map CompA to CompB.</li></ul><p>Lets have a test. Create a ActorBlueprint with name &quot;TestLoad&quot;, open it in BlueprintEditor, add variable with name &quot;Prefab&quot; and type &quot;LPrefab&quot;, assign the Prefab asset we just created above, link the node like the shot: <img src="'+k+'" alt=""> Now drag the actor &quot;TestLoad&quot; to LevelEditor&#39;s viewport then hit play, you will see the Prefab is successfully loaded and attach to &quot;TestLoad&quot; actor: <img src="'+I+'" alt=""></p><h3 id="initialize-when-load-prefab-at-runtime" tabindex="-1"><a class="header-anchor" href="#initialize-when-load-prefab-at-runtime" aria-hidden="true">#</a> Initialize when load Prefab at runtime</h3><p>LPrefab use it&#39;s own serialization policy and it is late than &quot;BeginPlay&quot; execution, so properties are not ready when &quot;BeginPlay&quot;, so a replacement for &quot;BeginPlay&quot; must use to do the initialization job.<br> LPrefab provide a way to achieve this:</p>',12),V=e("strong",null,"LPrefabInterface",-1),W=a('<p>Lets have a test. Create a ActorComponent with name &quot;TestInitialize&quot;, open it in BlueprintEditor, click on &quot;Class Settings&quot;, in the &quot;Implemented Interfaces&quot; area click &quot;Add&quot; button and typein <em>LPrefabInterface</em>: <img src="'+x+'" alt=""> Double click on &quot;Awake&quot; interface function, then drag out from &quot;Event Awake&quot; and link a &quot;PrintString&quot; node: <img src="'+B+'" alt=""> Double click on your Prefab asset to open Prefab-Editor, and drag TestInitialize component to any actor in prefab, then hit &quot;Apply&quot;: <img src="'+T+'" alt=""> Now hit play and you will see printed info right after the Prefab is loaded.</p><h3 id="delete-prefab-instance-at-runtime" tabindex="-1"><a class="header-anchor" href="#delete-prefab-instance-at-runtime" aria-hidden="true">#</a> Delete Prefab instance at runtime</h3><p>Prefab instance is just a collection of actors, so all we need to do is delete these actors. LPrefab provide a simple function to do it &quot;Destroy Actor with Hierarchy&quot;, just use it with the loaded prefab&#39;s root actor: <img src="'+N+'" alt=""></p><h2 id="nested-prefab-and-property-override" tabindex="-1"><a class="header-anchor" href="#nested-prefab-and-property-override" aria-hidden="true">#</a> Nested Prefab and Property Override</h2><p>Nested Prefab means you can include Prefab instances inside other Prefabs. Nested Prefabs retain their links to their own Prefab Assets, while also forming part of another Prefab Asset.<br> How to create a nested Prefab? This is simple, double click on Prefab asset to open a Prefab-Editor, click a actor to select it as parent, then drag another prefab to the Prefab-Editor&#39;s viewport, then you will find a instance of Prefab is created inside Prefab-Editor: <img src="'+R+'" alt=""> Prefab can maintain it&#39;s default property, and track changed property values for later <em>Apply</em> or <em>Revert</em>. For example, if I change the light color to red: <img src="'+S+'" alt=""> Goto Sub-Prefab&#39;s root Actor and right click LPrefab column in outliner, you will find &quot;Prefab Override Properties&quot;, click it and you can see the modified property: <img src="'+z+'" alt=""> You can <em>Revert</em> the modified property to Sub-Prefab&#39;s default value, or <em>Apply</em> the value to change the Sub-Prefab&#39;s default value.</p><p>There are some limitations when edit Sub-Prefab:</p><ul><li>Can&#39;t delete or remove Actor.</li><li>Can&#39;t delete or remove ActorComponent.</li><li>Can&#39;t change Actor&#39;s attachement.</li></ul><p>If we try to attach a actor to another, a message will showup to prevent it: <img src="'+U+'" alt=""></p><p><strong>KNOW LIMITATION</strong> Actor-Blueprint is not good with Prefab&#39;s workflow, so use it at your own risk.</p>',9);function H(J,K){const r=i("RouterLink");return c(),l("div",null,[O,e("p",null,[t("See "),o(r,{to:"/zh-cn/PrefabEditor/"},{default:s(()=>[t("PrefabEditor")]),_:1})]),j,e("ul",null,[e("li",null,[o(r,{to:"/zh-cn/PrefabInterface/"},{default:s(()=>[V]),_:1}),t(": Both Actor and ActorComponent can implement this interface.")])]),W])}const G=n(M,[["render",H],["__file","index.html.vue"]]);export{G as default};
